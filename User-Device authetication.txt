//User-Authetication Protocol

 

usertype SharedSecret;
protocol UserdeviceAuthentication(User,Device,TTP,Etheruem)
{
const Pprivate:Function;
const KPpublic:Function;
const Ppublic:Function;
const Pkprivate:Function;
const pk: Function;
const pr: Function;
secret sk:Function;
secret sr: Function;
inversekeys (pk,pr);
macro pk = pk(KPpublic);  // public key of Device  = pk(KPpublic)
macro pr = pk(Ppublic);   // public key of TTP(Trusted Third Party) = pk(Ppublic)
macro sk = sk(Pkprivate); // private key of device = sk(Pkprivate)
macro sr = sk(Pprivate);  // private key of TTP(Trusted Third Party) = sk(Pprivate)
macro UA= A;
macro Uaddress= a;

role User
 {
const A : Nonce;
const a : Nonce;
macro Usign = ((A,a),(pk) ,(sr));
send_1(User,Device,(A, a));
recv_7(Device,User,(Usign));
claim_u1(User,Nisynch);
claim_u2(User,Niagree);
}
role Device
{
const A : Nonce;
const a : Nonce;
macro Usign = ((A,a),(pk) ,(sr));
//The Trusted third party will generate a value (Usign)which will be encrypted by
//the device public key and signed by TTP private key. Usign holds the user values generated by etheruem BC
recv_1(User,Device,(A, a));
recv_2(TTP,Device,(pr));
send_3(Device,TTP,(A,a),(pr),pk);
recv_6(TTP,Device,Usign);
send_7(Device,User,(Usign));
claim_d1(Device,Secret,sk);
claim_d2(Device,Nisynch);
claim_d3(Device,Niagree);
}

role TTP
{
fresh U : Nonce;
const A : Nonce;
const a : Nonce;
send_2(TTP,Device,(pr));           // TTP SENDS PUBLIC KEY TO THE DEVICE
recv_3(Device,TTP,(A,a),(pr),pk);
send_4(TTP,Etheruem, (A,a));
recv_5( Etheruem,TTP, U);
send_6(TTP,Device ,(Usign));

claim_TTP1(TTP,Secret,sr);
claim_TTP2(TTP,Nisynch);
claim_TTP3(TTP,Niagree);
}
role Etheruem
{
fresh U : Nonce;
const A : Nonce;
const a : Nonce;
recv_4(TTP,Etheruem, (A,a));
send_5(Etheruem,TTP,U); //THE GENERATED BLOCK WILL CHECK IF THE USER IS REGISTERED
 claim_E1(Etheruem,Nisynch);
 claim_E2(Etheruem,Niagree);
 }
 }
