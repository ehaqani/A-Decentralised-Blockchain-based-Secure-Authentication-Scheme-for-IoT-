//Device- User Authetication Protocol

 

usertype SharedSecret;
protocol UserdeviceAuthentication(Device,User,TTP,Etheruem)
{
const Pprivate:Function;
const KPpublic:Function;
const Ppublic:Function;
const Pkprivate:Function;
const pk: Function;
const pr: Function;
secret sk:Function;
secret sr: Function;
inversekeys (pk,pr);
macro pk = pk(KPpublic);  // public key of User  = pk(KPpublic)
macro pr = pk(Ppublic);   // public key of TTP(Trusted Third Party) = pk(Ppublic)
macro sk = sk(Pkprivate); // private key of user = sk(Pkprivate)
macro sr = sk(Pprivate);  // private key of TTP(Trusted Third Party) = sk(Pprivate)
macro DA= D;
macro Daddress= d;

role Device
 {
const D : Nonce;
const d : Nonce;
macro DAsign = ((D,d),(pk) ,(sr));
send_1(Device,User,(D, d));
recv_7(User,Device,(DAsign));
claim_u1(Device,Nisynch);
claim_u2(Device,Niagree);
}
role User
{
const D : Nonce;
const d : Nonce;
macro DAsign = ((D,d),(pk) ,(sr));
//The Trusted third party will generate a value (DAsign)which will be encrypted by
//the user public key and signed by TTP private key. DAsign holds the user values generated by etheruem BC
recv_1(Device,User,(D, d));
recv_2(TTP,User,(pr));
send_3(User,TTP,(D,d),(pr),pk);
recv_6(TTP,User,DAsign);
send_7(User,Device,(DAsign));
claim_d1(User,Secret,sk);
claim_d2(User,Nisynch);
claim_d3(User,Niagree);
}

role TTP
{
fresh DA : Nonce;
const D : Nonce;
const d : Nonce;
send_2(TTP,User,(pr));           // TTP SENDS PUBLIC KEY TO THE User
recv_3(User,TTP,(D,d),(pr),pk);
send_4(TTP,Etheruem, (D,d));
recv_5( Etheruem,TTP, DA);
send_6(TTP,User ,(DAsign));

claim_TTP1(TTP,Secret,sr);
claim_TTP2(TTP,Nisynch);
claim_TTP3(TTP,Niagree);
}
role Etheruem
{
fresh DA : Nonce;
const D : Nonce;
const d : Nonce;
recv_4(TTP,Etheruem, (D,d));
send_5(Etheruem,TTP,DA); //THE GENERATED BLOCK WILL CHECK IF THE DEVICE IS REGISTERED
 claim_E1(Etheruem,Nisynch);
 claim_E2(Etheruem,Niagree);
 }
 }
